use strict;
use warnings;
package Camellia::Glue;

require Exporter;
our @ISA = qw(Exporter);
our @EXPORT = qw(
  load_module
  init_top write_top sign
  create_bundle create_raw create_inst
  );

my $module = {};

my $meta;

my ($port_buf, $assign_buf);
my ($wire_buf, $elem_buf);

sub init_top {
  my ($top, $file, $info) = @_;

  # clear buf
  $port_buf = $assign_buf = $wire_buf = $elem_buf = "";
  # assign top module name
  $meta = $info // {};
  $meta->{top} = $top;
  $meta->{file} = $file;

  # By default, always assign a fixed seed
  $meta->{seed} = srand ($meta->{seed} // 0xdeadbeef);
}

sub write_top {
  open TARGET, ">", $meta->{file};

  # Print generating information
  my $header = "";
  $header .= " * Author: $meta->{author}\n" if (defined $meta->{author});
  $header .= " * License: $meta->{license}\n" if (defined $meta->{license});
  $header .= " *\n" if ($header);

  print TARGET <<EOL_HEAD;
/*
$header * Generated by Camellia-Glue. Seed: $meta->{seed}
 */

EOL_HEAD

  print TARGET "module $meta->{top} ($port_buf\n);\n";
  print TARGET "\n$wire_buf\n" if ($wire_buf);
  print TARGET "$elem_buf\n" if ($elem_buf);
  print TARGET "$assign_buf\n" if ($assign_buf);
  print TARGET "endmodule\n";

  close TARGET;
}

sub sign {
  for my $elem (@_) {
    if ($elem->isa("Camellia::Glue::Bundle")) {
      # Connection check
      $elem->check();

      $port_buf .= $elem->gen_port(0 == ("" cmp $port_buf));
      $assign_buf .= $elem->gen_assign();
    } elsif ($elem->isa("Camellia::Glue::Rawcode")) {
      $elem_buf .= $elem->gen_code();
    } elsif ($elem->isa("Camellia::Glue::Inst")) {
      # Connection check
      $elem->check();

      $wire_buf .= $elem->gen_wire();
      $elem_buf .= $elem->gen_inst();
    } else {
      my ($package, $filename, $line) = caller;
      die "&$filename \@$line: Unknown type signed";
    }
  }
}

use File::Basename;
use Camellia::Glue::Bundle;

# Provide an safer way to create Bundle object. It hides low-level
# implementation, avoiding users using "Camellia::Glue::Bundle" directly.
sub create_bundle {
  my ($name, $group) = @_;
  $name //= "";

  my ($package, $filename, $line) = caller;
  return Camellia::Glue::Bundle->new({
    name => $name,
    group => $group,
    debug => "&" . basename($filename) . "; \@$line",
    is_top => 1
  });
}

use JSON::PP;

# load module definition from file
sub load_module {
  for my $path (@_) {
    open MODULE_FILE, "<$path" or die "Fail to open $path";
    my $content;
    while (<MODULE_FILE>) {
      $content .= $_;
    }
    close MODULE_FILE;

    my $config = decode_json $content;
    my $name = $config->{name};
    (defined $module->{$name}) and die "Multi-load of module \"$name\"";
    $module->{$name} = $config;
  }
}

use Camellia::Glue::Rawcode;
use Camellia::Glue::Inst;

sub create_raw {
  my ($code) = @_;
  my ($package, $filename, $line) = caller;

  return Camellia::Glue::Rawcode->new({
    code => $code,
    debug => "&" . basename($filename) . "; \@$line"
  });
}

sub create_inst {
  my ($mod_name, $name) = @_;
  my ($package, $filename, $line) = caller;

  my $config = $module->{$mod_name};
  die "Unknown module \"$mod_name\"" if !(defined $config);

  # Add the counter
  $config->{count} = (defined $config->{count}) ? $config->{count} + 1 : 0;

  return Camellia::Glue::Inst->new({
    name => $name // "u$config->{count}_$mod_name",
    mod_name => $mod_name,
    config => $config,
    debug => "&" . basename($filename) . "; \@$line"
  });
}

1;
